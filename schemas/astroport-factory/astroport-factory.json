{
  "contract_name": "astroport-factory",
  "contract_version": "2.0.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "This structure stores the basic settings for creating a new factory contract.",
    "type": "object",
    "required": [
      "coin_registry_address",
      "owner",
      "pair_configs",
      "token_code_id"
    ],
    "properties": {
      "coin_registry_address": {
        "description": "The address of the contract that contains the coins and their accuracy",
        "type": "string"
      },
      "fee_address": {
        "description": "Contract address to send governance fees to (the Maker)",
        "type": [
          "string",
          "null"
        ]
      },
      "generator_address": {
        "description": "Address of contract that is used to auto_stake LP tokens once someone provides liquidity in a pool",
        "type": [
          "string",
          "null"
        ]
      },
      "owner": {
        "description": "Address of owner that is allowed to change factory contract parameters",
        "type": "string"
      },
      "pair_configs": {
        "description": "IDs of contracts that are allowed to instantiate pairs",
        "type": "array",
        "items": {
          "$ref": "#/definitions/PairConfig"
        }
      },
      "token_code_id": {
        "description": "CW20 token contract code identifier",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      }
    },
    "additionalProperties": false,
    "definitions": {
      "PairConfig": {
        "description": "This structure stores a pair type's configuration.",
        "type": "object",
        "required": [
          "code_id",
          "maker_fee_bps",
          "pair_type",
          "total_fee_bps"
        ],
        "properties": {
          "code_id": {
            "description": "ID of contract which is allowed to create pairs of this type",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "is_disabled": {
            "description": "Whether a pair type is disabled or not. If it is disabled, new pairs cannot be created, but existing ones can still read the pair configuration Default is false.",
            "default": false,
            "type": "boolean"
          },
          "is_generator_disabled": {
            "description": "Setting this to true means that pairs of this type will not be able to get an ASTRO generator Default is false.",
            "default": false,
            "type": "boolean"
          },
          "maker_fee_bps": {
            "description": "The amount of fees (in bps) collected by the Maker contract from this pair type",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "pair_type": {
            "description": "The pair type (provided in a [`PairType`])",
            "allOf": [
              {
                "$ref": "#/definitions/PairType"
              }
            ]
          },
          "permissioned": {
            "description": "If pool type is permissioned, only factory owner can create pairs of this type. Default is false.",
            "default": false,
            "type": "boolean"
          },
          "total_fee_bps": {
            "description": "The total fees (in bps) charged by a pair of this type",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "whitelist": {
            "description": "If permissioned, this is a list of addresses that are allowed to create pairs of this type",
            "default": null,
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          }
        },
        "additionalProperties": false
      },
      "PairType": {
        "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
        "oneOf": [
          {
            "description": "XYK pair type",
            "type": "object",
            "required": [
              "xyk"
            ],
            "properties": {
              "xyk": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Stable pair type",
            "type": "object",
            "required": [
              "stable"
            ],
            "properties": {
              "stable": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Custom pair type",
            "type": "object",
            "required": [
              "custom"
            ],
            "properties": {
              "custom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "description": "This structure describes the execute messages of the contract.",
    "oneOf": [
      {
        "description": "UpdateConfig updates relevant code IDs",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "properties": {
              "coin_registry_address": {
                "description": "The address of the contract that contains the coins and their accuracy",
                "type": [
                  "string",
                  "null"
                ]
              },
              "fee_address": {
                "description": "Contract address to send governance fees to (the Maker)",
                "type": [
                  "string",
                  "null"
                ]
              },
              "generator_address": {
                "description": "Contract address where Lp tokens can be auto_staked after someone provides liquidity in an incentivized Astroport pool",
                "type": [
                  "string",
                  "null"
                ]
              },
              "token_code_id": {
                "description": "CW20 token contract code identifier",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "UpdatePairConfig updates the config for a pair type.",
        "type": "object",
        "required": [
          "update_pair_config"
        ],
        "properties": {
          "update_pair_config": {
            "type": "object",
            "required": [
              "config"
            ],
            "properties": {
              "config": {
                "description": "New [`PairConfig`] settings for a pair type",
                "allOf": [
                  {
                    "$ref": "#/definitions/PairConfig"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "CreatePair instantiates a new pair contract.",
        "type": "object",
        "required": [
          "create_pair"
        ],
        "properties": {
          "create_pair": {
            "type": "object",
            "required": [
              "asset_infos",
              "pair_type"
            ],
            "properties": {
              "asset_infos": {
                "description": "The assets to create the pool for",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/AssetInfo"
                }
              },
              "init_params": {
                "description": "Optional binary serialised parameters for custom pool types",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Binary"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "pair_type": {
                "description": "The pair type (exposed in [`PairType`])",
                "allOf": [
                  {
                    "$ref": "#/definitions/PairType"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "ProposeNewOwner creates a proposal to change contract ownership. The validity period for the proposal is set in the `expires_in` variable.",
        "type": "object",
        "required": [
          "propose_new_owner"
        ],
        "properties": {
          "propose_new_owner": {
            "type": "object",
            "required": [
              "expires_in",
              "owner"
            ],
            "properties": {
              "expires_in": {
                "description": "The date after which this proposal expires",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "owner": {
                "description": "Newly proposed contract owner",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "DropOwnershipProposal removes the existing offer to change contract ownership.",
        "type": "object",
        "required": [
          "drop_ownership_proposal"
        ],
        "properties": {
          "drop_ownership_proposal": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Used to claim contract ownership.",
        "type": "object",
        "required": [
          "claim_ownership"
        ],
        "properties": {
          "claim_ownership": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "AssetInfo": {
        "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
        "oneOf": [
          {
            "description": "Non-native Token",
            "type": "object",
            "required": [
              "token"
            ],
            "properties": {
              "token": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "$ref": "#/definitions/Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Native token",
            "type": "object",
            "required": [
              "native_token"
            ],
            "properties": {
              "native_token": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "PairConfig": {
        "description": "This structure stores a pair type's configuration.",
        "type": "object",
        "required": [
          "code_id",
          "maker_fee_bps",
          "pair_type",
          "total_fee_bps"
        ],
        "properties": {
          "code_id": {
            "description": "ID of contract which is allowed to create pairs of this type",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "is_disabled": {
            "description": "Whether a pair type is disabled or not. If it is disabled, new pairs cannot be created, but existing ones can still read the pair configuration Default is false.",
            "default": false,
            "type": "boolean"
          },
          "is_generator_disabled": {
            "description": "Setting this to true means that pairs of this type will not be able to get an ASTRO generator Default is false.",
            "default": false,
            "type": "boolean"
          },
          "maker_fee_bps": {
            "description": "The amount of fees (in bps) collected by the Maker contract from this pair type",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "pair_type": {
            "description": "The pair type (provided in a [`PairType`])",
            "allOf": [
              {
                "$ref": "#/definitions/PairType"
              }
            ]
          },
          "permissioned": {
            "description": "If pool type is permissioned, only factory owner can create pairs of this type. Default is false.",
            "default": false,
            "type": "boolean"
          },
          "total_fee_bps": {
            "description": "The total fees (in bps) charged by a pair of this type",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "whitelist": {
            "description": "If permissioned, this is a list of addresses that are allowed to create pairs of this type",
            "default": null,
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          }
        },
        "additionalProperties": false
      },
      "PairType": {
        "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
        "oneOf": [
          {
            "description": "XYK pair type",
            "type": "object",
            "required": [
              "xyk"
            ],
            "properties": {
              "xyk": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Stable pair type",
            "type": "object",
            "required": [
              "stable"
            ],
            "properties": {
              "stable": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Custom pair type",
            "type": "object",
            "required": [
              "custom"
            ],
            "properties": {
              "custom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "This structure describes the available query messages for the factory contract.",
    "oneOf": [
      {
        "description": "Config returns contract settings specified in the custom [`ConfigResponse`] structure.",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Pair returns information about a specific pair according to the specified assets. Gets the first pool from the list WARNING: this endpoint is left only for backward compatability. Consider using `QueryMsg::PairsByAssetInfos` and selecting a pool address based on your needs.",
        "type": "object",
        "required": [
          "pair"
        ],
        "properties": {
          "pair": {
            "type": "object",
            "required": [
              "asset_infos"
            ],
            "properties": {
              "asset_infos": {
                "description": "The assets for which we return a pair",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/AssetInfo"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "PairsByAssetInfos returns a list of pairs for the specified assets.",
        "type": "object",
        "required": [
          "pairs_by_asset_infos"
        ],
        "properties": {
          "pairs_by_asset_infos": {
            "type": "object",
            "required": [
              "asset_infos"
            ],
            "properties": {
              "asset_infos": {
                "description": "The assets for which we return a pair",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/AssetInfo"
                }
              },
              "limit": {
                "description": "The number of pairs to read and return. Optional",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "The pair address to start reading from. Optional",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "PairByLpToken returns a pair info for the specified liquidity token.",
        "type": "object",
        "required": [
          "pair_by_lp_token"
        ],
        "properties": {
          "pair_by_lp_token": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "description": "The liquidity token address for which we return a pair",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Pairs returns an array of pairs and their information according to the specified parameters in `start_after` and `limit` variables.",
        "type": "object",
        "required": [
          "pairs"
        ],
        "properties": {
          "pairs": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "The number of pairs to read and return. Optional",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "The pair address to start reading from. Optional",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "FeeInfo returns fee parameters for a specific pair. The response is returned using a [`FeeInfoResponse`] structure",
        "type": "object",
        "required": [
          "fee_info"
        ],
        "properties": {
          "fee_info": {
            "type": "object",
            "required": [
              "pair_type"
            ],
            "properties": {
              "pair_type": {
                "description": "The pair type for which we return fee information. Pair type is a [`PairType`] struct",
                "allOf": [
                  {
                    "$ref": "#/definitions/PairType"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns a vector that contains blacklisted pair types",
        "type": "object",
        "required": [
          "blacklisted_pair_types"
        ],
        "properties": {
          "blacklisted_pair_types": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "AssetInfo": {
        "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
        "oneOf": [
          {
            "description": "Non-native Token",
            "type": "object",
            "required": [
              "token"
            ],
            "properties": {
              "token": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "$ref": "#/definitions/Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Native token",
            "type": "object",
            "required": [
              "native_token"
            ],
            "properties": {
              "native_token": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "PairType": {
        "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
        "oneOf": [
          {
            "description": "XYK pair type",
            "type": "object",
            "required": [
              "xyk"
            ],
            "properties": {
              "xyk": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Stable pair type",
            "type": "object",
            "required": [
              "stable"
            ],
            "properties": {
              "stable": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Custom pair type",
            "type": "object",
            "required": [
              "custom"
            ],
            "properties": {
              "custom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "blacklisted_pair_types": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_PairType",
      "type": "array",
      "items": {
        "$ref": "#/definitions/PairType"
      },
      "definitions": {
        "PairType": {
          "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
          "oneOf": [
            {
              "description": "XYK pair type",
              "type": "object",
              "required": [
                "xyk"
              ],
              "properties": {
                "xyk": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Stable pair type",
              "type": "object",
              "required": [
                "stable"
              ],
              "properties": {
                "stable": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Custom pair type",
              "type": "object",
              "required": [
                "custom"
              ],
              "properties": {
                "custom": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ConfigResponse",
      "description": "A custom struct for each query response that returns general contract settings/configs.",
      "type": "object",
      "required": [
        "coin_registry_address",
        "owner",
        "pair_configs",
        "token_code_id"
      ],
      "properties": {
        "coin_registry_address": {
          "description": "The address of the contract that contains the coins and their accuracy",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "fee_address": {
          "description": "Address of contract to send governance fees to (the Maker)",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "generator_address": {
          "description": "Address of contract used to auto_stake LP tokens for Astroport pairs that are incentivized",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "owner": {
          "description": "Addres of owner that is allowed to change contract parameters",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "pair_configs": {
          "description": "IDs of contracts which are allowed to create pairs",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PairConfig"
          }
        },
        "token_code_id": {
          "description": "CW20 token contract code identifier",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "PairConfig": {
          "description": "This structure stores a pair type's configuration.",
          "type": "object",
          "required": [
            "code_id",
            "maker_fee_bps",
            "pair_type",
            "total_fee_bps"
          ],
          "properties": {
            "code_id": {
              "description": "ID of contract which is allowed to create pairs of this type",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_disabled": {
              "description": "Whether a pair type is disabled or not. If it is disabled, new pairs cannot be created, but existing ones can still read the pair configuration Default is false.",
              "default": false,
              "type": "boolean"
            },
            "is_generator_disabled": {
              "description": "Setting this to true means that pairs of this type will not be able to get an ASTRO generator Default is false.",
              "default": false,
              "type": "boolean"
            },
            "maker_fee_bps": {
              "description": "The amount of fees (in bps) collected by the Maker contract from this pair type",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "pair_type": {
              "description": "The pair type (provided in a [`PairType`])",
              "allOf": [
                {
                  "$ref": "#/definitions/PairType"
                }
              ]
            },
            "permissioned": {
              "description": "If pool type is permissioned, only factory owner can create pairs of this type. Default is false.",
              "default": false,
              "type": "boolean"
            },
            "total_fee_bps": {
              "description": "The total fees (in bps) charged by a pair of this type",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "whitelist": {
              "description": "If permissioned, this is a list of addresses that are allowed to create pairs of this type",
              "default": null,
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            }
          },
          "additionalProperties": false
        },
        "PairType": {
          "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
          "oneOf": [
            {
              "description": "XYK pair type",
              "type": "object",
              "required": [
                "xyk"
              ],
              "properties": {
                "xyk": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Stable pair type",
              "type": "object",
              "required": [
                "stable"
              ],
              "properties": {
                "stable": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Custom pair type",
              "type": "object",
              "required": [
                "custom"
              ],
              "properties": {
                "custom": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "fee_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FeeInfoResponse",
      "description": "A custom struct for each query response that returns an object of type [`FeeInfoResponse`].",
      "type": "object",
      "required": [
        "maker_fee_bps",
        "total_fee_bps"
      ],
      "properties": {
        "fee_address": {
          "description": "Contract address to send governance fees to",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "maker_fee_bps": {
          "description": "Amount of fees (in bps) sent to the Maker contract",
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        },
        "total_fee_bps": {
          "description": "Total amount of fees (in bps) charged on a swap",
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "pair": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PairInfo",
      "description": "This structure stores the main parameters for an Astroport pair",
      "type": "object",
      "required": [
        "asset_infos",
        "contract_addr",
        "liquidity_token",
        "pair_type"
      ],
      "properties": {
        "asset_infos": {
          "description": "Asset information for the assets in the pool",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AssetInfo"
          }
        },
        "contract_addr": {
          "description": "Pair contract address",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "liquidity_token": {
          "description": "Pair LP token denom",
          "type": "string"
        },
        "pair_type": {
          "description": "The pool type (xyk, stableswap etc) available in [`PairType`]",
          "allOf": [
            {
              "$ref": "#/definitions/PairType"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PairType": {
          "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
          "oneOf": [
            {
              "description": "XYK pair type",
              "type": "object",
              "required": [
                "xyk"
              ],
              "properties": {
                "xyk": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Stable pair type",
              "type": "object",
              "required": [
                "stable"
              ],
              "properties": {
                "stable": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Custom pair type",
              "type": "object",
              "required": [
                "custom"
              ],
              "properties": {
                "custom": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "pair_by_lp_token": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PairInfo",
      "description": "This structure stores the main parameters for an Astroport pair",
      "type": "object",
      "required": [
        "asset_infos",
        "contract_addr",
        "liquidity_token",
        "pair_type"
      ],
      "properties": {
        "asset_infos": {
          "description": "Asset information for the assets in the pool",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AssetInfo"
          }
        },
        "contract_addr": {
          "description": "Pair contract address",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "liquidity_token": {
          "description": "Pair LP token denom",
          "type": "string"
        },
        "pair_type": {
          "description": "The pool type (xyk, stableswap etc) available in [`PairType`]",
          "allOf": [
            {
              "$ref": "#/definitions/PairType"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PairType": {
          "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
          "oneOf": [
            {
              "description": "XYK pair type",
              "type": "object",
              "required": [
                "xyk"
              ],
              "properties": {
                "xyk": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Stable pair type",
              "type": "object",
              "required": [
                "stable"
              ],
              "properties": {
                "stable": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Custom pair type",
              "type": "object",
              "required": [
                "custom"
              ],
              "properties": {
                "custom": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "pairs": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PairsResponse",
      "description": "A custom struct for each query response that returns an array of objects of type [`PairInfo`].",
      "type": "object",
      "required": [
        "pairs"
      ],
      "properties": {
        "pairs": {
          "description": "Arrays of structs containing information about multiple pairs",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PairInfo"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PairInfo": {
          "description": "This structure stores the main parameters for an Astroport pair",
          "type": "object",
          "required": [
            "asset_infos",
            "contract_addr",
            "liquidity_token",
            "pair_type"
          ],
          "properties": {
            "asset_infos": {
              "description": "Asset information for the assets in the pool",
              "type": "array",
              "items": {
                "$ref": "#/definitions/AssetInfo"
              }
            },
            "contract_addr": {
              "description": "Pair contract address",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "liquidity_token": {
              "description": "Pair LP token denom",
              "type": "string"
            },
            "pair_type": {
              "description": "The pool type (xyk, stableswap etc) available in [`PairType`]",
              "allOf": [
                {
                  "$ref": "#/definitions/PairType"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PairType": {
          "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
          "oneOf": [
            {
              "description": "XYK pair type",
              "type": "object",
              "required": [
                "xyk"
              ],
              "properties": {
                "xyk": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Stable pair type",
              "type": "object",
              "required": [
                "stable"
              ],
              "properties": {
                "stable": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Custom pair type",
              "type": "object",
              "required": [
                "custom"
              ],
              "properties": {
                "custom": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "pairs_by_asset_infos": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_PairInfo",
      "type": "array",
      "items": {
        "$ref": "#/definitions/PairInfo"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PairInfo": {
          "description": "This structure stores the main parameters for an Astroport pair",
          "type": "object",
          "required": [
            "asset_infos",
            "contract_addr",
            "liquidity_token",
            "pair_type"
          ],
          "properties": {
            "asset_infos": {
              "description": "Asset information for the assets in the pool",
              "type": "array",
              "items": {
                "$ref": "#/definitions/AssetInfo"
              }
            },
            "contract_addr": {
              "description": "Pair contract address",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "liquidity_token": {
              "description": "Pair LP token denom",
              "type": "string"
            },
            "pair_type": {
              "description": "The pool type (xyk, stableswap etc) available in [`PairType`]",
              "allOf": [
                {
                  "$ref": "#/definitions/PairType"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PairType": {
          "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
          "oneOf": [
            {
              "description": "XYK pair type",
              "type": "object",
              "required": [
                "xyk"
              ],
              "properties": {
                "xyk": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Stable pair type",
              "type": "object",
              "required": [
                "stable"
              ],
              "properties": {
                "stable": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Custom pair type",
              "type": "object",
              "required": [
                "custom"
              ],
              "properties": {
                "custom": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    }
  }
}
