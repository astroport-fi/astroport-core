{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ExecuteMsg",
  "oneOf": [
    {
      "description": "Execute requests the contract to re-dispatch all these messages with the contract's address as sender. Every implementation has it's own logic to determine in",
      "type": "object",
      "required": [
        "execute"
      ],
      "properties": {
        "execute": {
          "type": "object",
          "required": [
            "msgs"
          ],
          "properties": {
            "msgs": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/CosmosMsg_for_NeutronMsg"
              }
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Freeze will make a mutable contract immutable, must be called by an admin",
      "type": "object",
      "required": [
        "freeze"
      ],
      "properties": {
        "freeze": {
          "type": "object",
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "UpdateAdmins will change the admin set of the contract, must be called by an existing admin, and only works if the contract is mutable",
      "type": "object",
      "required": [
        "update_admins"
      ],
      "properties": {
        "update_admins": {
          "type": "object",
          "required": [
            "admins"
          ],
          "properties": {
            "admins": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    }
  ],
  "definitions": {
    "AdminProposal": {
      "description": "AdminProposal defines the struct for various proposals which Neutron's Admin Module may accept.",
      "oneOf": [
        {
          "description": "Proposal to change params. Note that this works for old params. New params has their own `MsgUpdateParams` msgs that can be supplied to `ProposalExecuteMessage`",
          "type": "object",
          "required": [
            "param_change_proposal"
          ],
          "properties": {
            "param_change_proposal": {
              "$ref": "#/definitions/ParamChangeProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Proposal to upgrade IBC client",
          "type": "object",
          "required": [
            "upgrade_proposal"
          ],
          "properties": {
            "upgrade_proposal": {
              "$ref": "#/definitions/UpgradeProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Proposal to update IBC client",
          "type": "object",
          "required": [
            "client_update_proposal"
          ],
          "properties": {
            "client_update_proposal": {
              "$ref": "#/definitions/ClientUpdateProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Proposal to execute CosmosMsg.",
          "type": "object",
          "required": [
            "proposal_execute_message"
          ],
          "properties": {
            "proposal_execute_message": {
              "$ref": "#/definitions/ProposalExecuteMessage"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to upgrade network",
          "deprecated": true,
          "type": "object",
          "required": [
            "software_upgrade_proposal"
          ],
          "properties": {
            "software_upgrade_proposal": {
              "$ref": "#/definitions/SoftwareUpgradeProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to cancel existing software upgrade",
          "deprecated": true,
          "type": "object",
          "required": [
            "cancel_software_upgrade_proposal"
          ],
          "properties": {
            "cancel_software_upgrade_proposal": {
              "$ref": "#/definitions/CancelSoftwareUpgradeProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Will fail to execute if you use it. Deprecated. Proposal to pin wasm contract codes",
          "deprecated": true,
          "type": "object",
          "required": [
            "pin_codes_proposal"
          ],
          "properties": {
            "pin_codes_proposal": {
              "$ref": "#/definitions/PinCodesProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Deprecated. Proposal to unpin wasm contract codes.",
          "deprecated": true,
          "type": "object",
          "required": [
            "unpin_codes_proposal"
          ],
          "properties": {
            "unpin_codes_proposal": {
              "$ref": "#/definitions/UnpinCodesProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to call sudo on contract.",
          "deprecated": true,
          "type": "object",
          "required": [
            "sudo_contract_proposal"
          ],
          "properties": {
            "sudo_contract_proposal": {
              "$ref": "#/definitions/SudoContractProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to update contract admin.",
          "deprecated": true,
          "type": "object",
          "required": [
            "update_admin_proposal"
          ],
          "properties": {
            "update_admin_proposal": {
              "$ref": "#/definitions/UpdateAdminProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to clear contract admin.",
          "deprecated": true,
          "type": "object",
          "required": [
            "clear_admin_proposal"
          ],
          "properties": {
            "clear_admin_proposal": {
              "$ref": "#/definitions/ClearAdminProposal"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "BankMsg": {
      "description": "The message types of the bank module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto",
      "oneOf": [
        {
          "description": "Sends native tokens from the contract to the given address.\n\nThis is translated to a [MsgSend](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto#L19-L28). `from_address` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "send"
          ],
          "properties": {
            "send": {
              "type": "object",
              "required": [
                "amount",
                "to_address"
              ],
              "properties": {
                "amount": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                },
                "to_address": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "This will burn the given coins from the contract's account. There is no Cosmos SDK message that performs this, but it can be done by calling the bank keeper. Important if a contract controls significant token supply that must be retired.",
          "type": "object",
          "required": [
            "burn"
          ],
          "properties": {
            "burn": {
              "type": "object",
              "required": [
                "amount"
              ],
              "properties": {
                "amount": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              }
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Binary": {
      "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
      "type": "string"
    },
    "CancelSoftwareUpgradeProposal": {
      "description": "Deprecated. CancelSoftwareUpgradeProposal defines the struct for cancel software upgrade proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "description",
        "title"
      ],
      "properties": {
        "description": {
          "description": "*description** is a text description of proposal. Non unique.",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal. Non unique.",
          "type": "string"
        }
      }
    },
    "ClearAdminProposal": {
      "description": "Deprecated. SudoContractProposal defines the struct for clear admin proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "contract",
        "description",
        "title"
      ],
      "properties": {
        "contract": {
          "description": "*contract** is an address of contract admin will be removed.",
          "type": "string"
        },
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      }
    },
    "ClientUpdateProposal": {
      "description": "ClientUpdateProposal defines the struct for client update proposal.",
      "type": "object",
      "required": [
        "description",
        "subject_client_id",
        "substitute_client_id",
        "title"
      ],
      "properties": {
        "description": {
          "description": "*description** is a text description of proposal. Non unique.",
          "type": "string"
        },
        "subject_client_id": {
          "description": "*subject_client_id** is a subject client id.",
          "type": "string"
        },
        "substitute_client_id": {
          "description": "*substitute_client_id** is a substitute client id.",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      }
    },
    "Coin": {
      "type": "object",
      "required": [
        "amount",
        "denom"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "denom": {
          "type": "string"
        }
      }
    },
    "CosmosMsg_for_NeutronMsg": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "bank"
          ],
          "properties": {
            "bank": {
              "$ref": "#/definitions/BankMsg"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "custom"
          ],
          "properties": {
            "custom": {
              "$ref": "#/definitions/NeutronMsg"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "staking"
          ],
          "properties": {
            "staking": {
              "$ref": "#/definitions/StakingMsg"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "distribution"
          ],
          "properties": {
            "distribution": {
              "$ref": "#/definitions/DistributionMsg"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "A Stargate message encoded the same way as a protobuf [Any](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto). This is the same structure as messages in `TxBody` from [ADR-020](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-020-protobuf-transaction-encoding.md)",
          "type": "object",
          "required": [
            "stargate"
          ],
          "properties": {
            "stargate": {
              "type": "object",
              "required": [
                "type_url",
                "value"
              ],
              "properties": {
                "type_url": {
                  "type": "string"
                },
                "value": {
                  "$ref": "#/definitions/Binary"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "ibc"
          ],
          "properties": {
            "ibc": {
              "$ref": "#/definitions/IbcMsg"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "wasm"
          ],
          "properties": {
            "wasm": {
              "$ref": "#/definitions/WasmMsg"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "gov"
          ],
          "properties": {
            "gov": {
              "$ref": "#/definitions/GovMsg"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "DenomUnit": {
      "description": "Replicates the cosmos-sdk bank module DenomUnit type",
      "type": "object",
      "required": [
        "aliases",
        "denom",
        "exponent"
      ],
      "properties": {
        "aliases": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "denom": {
          "type": "string"
        },
        "exponent": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "DistributionMsg": {
      "description": "The message types of the distribution module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto",
      "oneOf": [
        {
          "description": "This is translated to a [MsgSetWithdrawAddress](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L29-L37). `delegator_address` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "set_withdraw_address"
          ],
          "properties": {
            "set_withdraw_address": {
              "type": "object",
              "required": [
                "address"
              ],
              "properties": {
                "address": {
                  "description": "The `withdraw_address`",
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "This is translated to a [[MsgWithdrawDelegatorReward](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L42-L50). `delegator_address` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "withdraw_delegator_reward"
          ],
          "properties": {
            "withdraw_delegator_reward": {
              "type": "object",
              "required": [
                "validator"
              ],
              "properties": {
                "validator": {
                  "description": "The `validator_address`",
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "GovMsg": {
      "description": "This message type allows the contract interact with the [x/gov] module in order to cast votes.\n\n[x/gov]: https://github.com/cosmos/cosmos-sdk/tree/v0.45.12/x/gov\n\n## Examples\n\nCast a simple vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); use cosmwasm_std::{GovMsg, VoteOption};\n\n#[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::Vote { proposal_id: 4, vote: VoteOption::Yes, })) } ```\n\nCast a weighted vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); # #[cfg(feature = \"cosmwasm_1_2\")] use cosmwasm_std::{Decimal, GovMsg, VoteOption, WeightedVoteOption};\n\n# #[cfg(feature = \"cosmwasm_1_2\")] #[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::VoteWeighted { proposal_id: 4, options: vec![ WeightedVoteOption { option: VoteOption::Yes, weight: Decimal::percent(65), }, WeightedVoteOption { option: VoteOption::Abstain, weight: Decimal::percent(35), }, ], })) } ```",
      "oneOf": [
        {
          "description": "This maps directly to [MsgVote](https://github.com/cosmos/cosmos-sdk/blob/v0.42.5/proto/cosmos/gov/v1beta1/tx.proto#L46-L56) in the Cosmos SDK with voter set to the contract address.",
          "type": "object",
          "required": [
            "vote"
          ],
          "properties": {
            "vote": {
              "type": "object",
              "required": [
                "proposal_id",
                "vote"
              ],
              "properties": {
                "proposal_id": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                },
                "vote": {
                  "description": "The vote option.\n\nThis should be called \"option\" for consistency with Cosmos SDK. Sorry for that. See <https://github.com/CosmWasm/cosmwasm/issues/1571>.",
                  "allOf": [
                    {
                      "$ref": "#/definitions/VoteOption"
                    }
                  ]
                }
              }
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "IbcFee": {
      "description": "IbcFee defines struct for fees that refund the relayer for `SudoMsg` messages submission. Unused fee kind will be returned back to message sender. Please refer to these links for more information: IBC transaction structure - <https://docs.neutron.org/neutron/interchain-txs/messages/#msgsubmittx> General mechanics of fee payments - <https://docs.neutron.org/neutron/feerefunder/overview/#general-mechanics>",
      "type": "object",
      "required": [
        "ack_fee",
        "recv_fee",
        "timeout_fee"
      ],
      "properties": {
        "ack_fee": {
          "description": "*ack_fee** is an amount of coins to refund relayer for submitting ack message for a particular IBC packet.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Coin"
          }
        },
        "recv_fee": {
          "description": "**recv_fee** currently is used for compatibility with ICS-29 interface only and must be set to zero (i.e. 0untrn), because Neutron's fee module can't refund relayer for submission of Recv IBC packets due to compatibility with target chains.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Coin"
          }
        },
        "timeout_fee": {
          "description": "*timeout_fee** amount of coins to refund relayer for submitting timeout message for a particular IBC packet.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Coin"
          }
        }
      }
    },
    "IbcMsg": {
      "description": "These are messages in the IBC lifecycle. Only usable by IBC-enabled contracts (contracts that directly speak the IBC protocol via 6 entry points)",
      "oneOf": [
        {
          "description": "Sends bank tokens owned by the contract to the given address on another chain. The channel must already be established between the ibctransfer module on this chain and a matching module on the remote chain. We cannot select the port_id, this is whatever the local chain has bound the ibctransfer module to.",
          "type": "object",
          "required": [
            "transfer"
          ],
          "properties": {
            "transfer": {
              "type": "object",
              "required": [
                "amount",
                "channel_id",
                "timeout",
                "to_address"
              ],
              "properties": {
                "amount": {
                  "description": "packet data only supports one coin https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20",
                  "allOf": [
                    {
                      "$ref": "#/definitions/Coin"
                    }
                  ]
                },
                "channel_id": {
                  "description": "existing channel to send the tokens over",
                  "type": "string"
                },
                "timeout": {
                  "description": "when packet times out, measured on remote chain",
                  "allOf": [
                    {
                      "$ref": "#/definitions/IbcTimeout"
                    }
                  ]
                },
                "to_address": {
                  "description": "address on the remote chain to receive these tokens",
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Sends an IBC packet with given data over the existing channel. Data should be encoded in a format defined by the channel version, and the module on the other side should know how to parse this.",
          "type": "object",
          "required": [
            "send_packet"
          ],
          "properties": {
            "send_packet": {
              "type": "object",
              "required": [
                "channel_id",
                "data",
                "timeout"
              ],
              "properties": {
                "channel_id": {
                  "type": "string"
                },
                "data": {
                  "$ref": "#/definitions/Binary"
                },
                "timeout": {
                  "description": "when packet times out, measured on remote chain",
                  "allOf": [
                    {
                      "$ref": "#/definitions/IbcTimeout"
                    }
                  ]
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "This will close an existing channel that is owned by this contract. Port is auto-assigned to the contract's IBC port",
          "type": "object",
          "required": [
            "close_channel"
          ],
          "properties": {
            "close_channel": {
              "type": "object",
              "required": [
                "channel_id"
              ],
              "properties": {
                "channel_id": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "IbcTimeout": {
      "description": "In IBC each package must set at least one type of timeout: the timestamp or the block height. Using this rather complex enum instead of two timeout fields we ensure that at least one timeout is set.",
      "type": "object",
      "properties": {
        "block": {
          "anyOf": [
            {
              "$ref": "#/definitions/IbcTimeoutBlock"
            },
            {
              "type": "null"
            }
          ]
        },
        "timestamp": {
          "anyOf": [
            {
              "$ref": "#/definitions/Timestamp"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "IbcTimeoutBlock": {
      "description": "IBCTimeoutHeight Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients. Ordering is (revision_number, timeout_height)",
      "type": "object",
      "required": [
        "height",
        "revision"
      ],
      "properties": {
        "height": {
          "description": "block height after which the packet times out. the height within the given revision",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "revision": {
          "description": "the version that the client is currently on (e.g. after resetting the chain this could increment 1 as height drops to 0)",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "KVKey": {
      "description": "Describes a KV key for which you want to get value from the storage on remote chain",
      "type": "object",
      "required": [
        "key",
        "path"
      ],
      "properties": {
        "key": {
          "description": "*key** is a key you want to read from the storage",
          "allOf": [
            {
              "$ref": "#/definitions/Binary"
            }
          ]
        },
        "path": {
          "description": "*path** is a path to the storage (storage prefix) where you want to read value by key (usually name of cosmos-packages module: 'staking', 'bank', etc.)",
          "type": "string"
        }
      }
    },
    "MsgExecuteContract": {
      "description": "MsgExecuteContract defines a call to the contract execution",
      "type": "object",
      "required": [
        "contract",
        "msg"
      ],
      "properties": {
        "contract": {
          "description": "*contract** is a contract address that will be called",
          "type": "string"
        },
        "msg": {
          "description": "*msg** is a contract call message",
          "type": "string"
        }
      }
    },
    "NeutronMsg": {
      "description": "A number of Custom messages that can call into the Neutron bindings.",
      "oneOf": [
        {
          "description": "RegisterInterchainAccount registers an interchain account on remote chain.",
          "type": "object",
          "required": [
            "register_interchain_account"
          ],
          "properties": {
            "register_interchain_account": {
              "type": "object",
              "required": [
                "connection_id",
                "interchain_account_id"
              ],
              "properties": {
                "connection_id": {
                  "description": "*connection_id** is an IBC connection identifier between Neutron and remote chain.",
                  "type": "string"
                },
                "interchain_account_id": {
                  "description": "**interchain_account_id** is an identifier of your new interchain account. Can be any string. This identifier allows contracts to have multiple interchain accounts on remote chains.",
                  "type": "string"
                },
                "register_fee": {
                  "description": "*register_fee** is a fees required to be payed to register interchain account",
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "SubmitTx starts the process of executing any Cosmos-SDK *msgs* on remote chain.",
          "type": "object",
          "required": [
            "submit_tx"
          ],
          "properties": {
            "submit_tx": {
              "type": "object",
              "required": [
                "connection_id",
                "fee",
                "interchain_account_id",
                "memo",
                "msgs",
                "timeout"
              ],
              "properties": {
                "connection_id": {
                  "description": "*connection_id** is an IBC connection identifier between Neutron and remote chain.",
                  "type": "string"
                },
                "fee": {
                  "description": "**fee** is an ibc fee for the transaction.",
                  "allOf": [
                    {
                      "$ref": "#/definitions/IbcFee"
                    }
                  ]
                },
                "interchain_account_id": {
                  "description": "*interchain_account_id** is an identifier of your interchain account from which you want to execute msgs.",
                  "type": "string"
                },
                "memo": {
                  "description": "*memo** is a memo you want to attach to your interchain transaction.It behaves like a memo in usual Cosmos transaction.",
                  "type": "string"
                },
                "msgs": {
                  "description": "*msgs** is a list of protobuf encoded Cosmos-SDK messages you want to execute on remote chain.",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/ProtobufAny"
                  }
                },
                "timeout": {
                  "description": "*timeout** is a timeout in seconds after which the packet times out.",
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "RegisterInterchainQuery registers an interchain query.",
          "type": "object",
          "required": [
            "register_interchain_query"
          ],
          "properties": {
            "register_interchain_query": {
              "type": "object",
              "required": [
                "connection_id",
                "keys",
                "query_type",
                "transactions_filter",
                "update_period"
              ],
              "properties": {
                "connection_id": {
                  "description": "*connection_id** is an IBC connection identifier between Neutron and remote chain.",
                  "type": "string"
                },
                "keys": {
                  "description": "*keys** is the KV-storage keys for which we want to get values from remote chain.",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/KVKey"
                  }
                },
                "query_type": {
                  "description": "*query_type** is a query type identifier ('tx' or 'kv' for now).",
                  "type": "string"
                },
                "transactions_filter": {
                  "description": "*transactions_filter** is the filter for transaction search ICQ.",
                  "type": "string"
                },
                "update_period": {
                  "description": "*update_period** is used to say how often the query must be updated.",
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "RegisterInterchainQuery updates an interchain query.",
          "type": "object",
          "required": [
            "update_interchain_query"
          ],
          "properties": {
            "update_interchain_query": {
              "type": "object",
              "required": [
                "query_id"
              ],
              "properties": {
                "new_keys": {
                  "description": "*new_keys** is the new query keys to retrive.",
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "$ref": "#/definitions/KVKey"
                  }
                },
                "new_transactions_filter": {
                  "description": "*new_transactions_filter** is a new transactions filter of the query.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "new_update_period": {
                  "description": "*new_update_period** is a new update period of the query.",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "format": "uint64",
                  "minimum": 0.0
                },
                "query_id": {
                  "description": "*query_id** is the ID of the query we want to update.",
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "RemoveInterchainQuery removes as interchain query.",
          "type": "object",
          "required": [
            "remove_interchain_query"
          ],
          "properties": {
            "remove_interchain_query": {
              "type": "object",
              "required": [
                "query_id"
              ],
              "properties": {
                "query_id": {
                  "description": "*query_id** is ID of the query we want to remove.",
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "IbcTransfer sends a fungible token packet over IBC.",
          "type": "object",
          "required": [
            "ibc_transfer"
          ],
          "properties": {
            "ibc_transfer": {
              "type": "object",
              "required": [
                "fee",
                "memo",
                "receiver",
                "sender",
                "source_channel",
                "source_port",
                "timeout_height",
                "timeout_timestamp",
                "token"
              ],
              "properties": {
                "fee": {
                  "$ref": "#/definitions/IbcFee"
                },
                "memo": {
                  "type": "string"
                },
                "receiver": {
                  "type": "string"
                },
                "sender": {
                  "type": "string"
                },
                "source_channel": {
                  "type": "string"
                },
                "source_port": {
                  "type": "string"
                },
                "timeout_height": {
                  "$ref": "#/definitions/RequestPacketTimeoutHeight"
                },
                "timeout_timestamp": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                },
                "token": {
                  "$ref": "#/definitions/Coin"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "SubmitAdminProposal sends a proposal to neutron's Admin module. This type of messages can be only executed by Neutron DAO.",
          "type": "object",
          "required": [
            "submit_admin_proposal"
          ],
          "properties": {
            "submit_admin_proposal": {
              "type": "object",
              "required": [
                "admin_proposal"
              ],
              "properties": {
                "admin_proposal": {
                  "$ref": "#/definitions/AdminProposal"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "TokenFactory message. Contracts can create denoms, namespaced under the contract's address. A contract may create any number of independent sub-denoms.",
          "type": "object",
          "required": [
            "create_denom"
          ],
          "properties": {
            "create_denom": {
              "type": "object",
              "required": [
                "subdenom"
              ],
              "properties": {
                "subdenom": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "TokenFactory message. Contracts can change the admin of a denom that they are the admin of.",
          "type": "object",
          "required": [
            "change_admin"
          ],
          "properties": {
            "change_admin": {
              "type": "object",
              "required": [
                "denom",
                "new_admin_address"
              ],
              "properties": {
                "denom": {
                  "type": "string"
                },
                "new_admin_address": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "TokenFactory message. Contracts can mint native tokens for an existing factory denom that they are the admin of.",
          "type": "object",
          "required": [
            "mint_tokens"
          ],
          "properties": {
            "mint_tokens": {
              "type": "object",
              "required": [
                "amount",
                "denom",
                "mint_to_address"
              ],
              "properties": {
                "amount": {
                  "$ref": "#/definitions/Uint128"
                },
                "denom": {
                  "type": "string"
                },
                "mint_to_address": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "TokenFactory message. Contracts can burn native tokens for an existing factory denom that they are the admin of. Currently, the burn from address must be the admin contract.",
          "type": "object",
          "required": [
            "burn_tokens"
          ],
          "properties": {
            "burn_tokens": {
              "type": "object",
              "required": [
                "amount",
                "burn_from_address",
                "denom"
              ],
              "properties": {
                "amount": {
                  "$ref": "#/definitions/Uint128"
                },
                "burn_from_address": {
                  "description": "Must be set to `\"\"` for now",
                  "type": "string"
                },
                "denom": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "TokenFactory message. Contracts can set before send hooks for denoms, namespaced under the contract's address.",
          "type": "object",
          "required": [
            "set_before_send_hook"
          ],
          "properties": {
            "set_before_send_hook": {
              "type": "object",
              "required": [
                "contract_addr",
                "denom"
              ],
              "properties": {
                "contract_addr": {
                  "type": "string"
                },
                "denom": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "TokenFactoryMessage Contracts can force specified `amount` of an existing factory denom that they are admin of to a `transfer_to_address` from a `transfer_from_address`.",
          "type": "object",
          "required": [
            "force_transfer"
          ],
          "properties": {
            "force_transfer": {
              "type": "object",
              "required": [
                "amount",
                "denom",
                "transfer_from_address",
                "transfer_to_address"
              ],
              "properties": {
                "amount": {
                  "$ref": "#/definitions/Uint128"
                },
                "denom": {
                  "type": "string"
                },
                "transfer_from_address": {
                  "type": "string"
                },
                "transfer_to_address": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "TokenFactoryMessage Contracts can set a metadata for of an existing factory denom that they are admin of.",
          "type": "object",
          "required": [
            "set_denom_metadata"
          ],
          "properties": {
            "set_denom_metadata": {
              "type": "object",
              "required": [
                "base",
                "denom_units",
                "description",
                "display",
                "name",
                "symbol",
                "uri",
                "uri_hash"
              ],
              "properties": {
                "base": {
                  "description": "*base** represents the base denom (should be the DenomUnit with exponent = 0).",
                  "type": "string"
                },
                "denom_units": {
                  "description": "*denom_units** represents the list of DenomUnit's for a given coin",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/DenomUnit"
                  }
                },
                "description": {
                  "description": "*description** description of a token",
                  "type": "string"
                },
                "display": {
                  "description": "**display** indicates the suggested denom that should be displayed in clients.",
                  "type": "string"
                },
                "name": {
                  "description": "*name** defines the name of the token (eg: Cosmos Atom)",
                  "type": "string"
                },
                "symbol": {
                  "description": "**symbol** is the token symbol usually shown on exchanges (eg: ATOM). This can be the same as the display.",
                  "type": "string"
                },
                "uri": {
                  "description": "*uri** to a document (on or off-chain) that contains additional information. Optional.",
                  "type": "string"
                },
                "uri_hash": {
                  "description": "**uri_hash** is a sha256 hash of a document pointed by URI. It's used to verify that the document didn't change. Optional.",
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "AddSchedule adds new schedule with a given `name`. Until schedule is removed it will execute all `msgs` every `period` blocks. First execution is at least on `current_block + period` block. [Permissioned - DAO Only]",
          "type": "object",
          "required": [
            "add_schedule"
          ],
          "properties": {
            "add_schedule": {
              "type": "object",
              "required": [
                "msgs",
                "name",
                "period"
              ],
              "properties": {
                "msgs": {
                  "description": "list of cosmwasm messages to be executed",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/MsgExecuteContract"
                  }
                },
                "name": {
                  "description": "Name of a new schedule. Needed to be able to `RemoveSchedule` and to log information about it",
                  "type": "string"
                },
                "period": {
                  "description": "period in blocks with which `msgs` will be executed",
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "RemoveSchedule removes the schedule with a given `name`. [Permissioned - DAO or Security DAO only]",
          "type": "object",
          "required": [
            "remove_schedule"
          ],
          "properties": {
            "remove_schedule": {
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Contractmanager message Resubmits failed acknowledgement. Acknowledgement failure is created when contract returns error or acknowledgement is out of gas. [Permissioned - only from contract that is initial caller of IBC transaction]",
          "type": "object",
          "required": [
            "resubmit_failure"
          ],
          "properties": {
            "resubmit_failure": {
              "type": "object",
              "required": [
                "failure_id"
              ],
              "properties": {
                "failure_id": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              }
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ParamChange": {
      "description": "ParamChange defines the struct for parameter change request.",
      "type": "object",
      "required": [
        "key",
        "subspace",
        "value"
      ],
      "properties": {
        "key": {
          "description": "*key** is a name of parameter. Unique for subspace.",
          "type": "string"
        },
        "subspace": {
          "description": "*subspace** is a key of module to which the parameter to change belongs. Unique for each module.",
          "type": "string"
        },
        "value": {
          "description": "*value** is a new value for given parameter. Non unique.",
          "type": "string"
        }
      }
    },
    "ParamChangeProposal": {
      "description": "ParamChangeProposal defines the struct for single parameter change proposal.",
      "type": "object",
      "required": [
        "description",
        "param_changes",
        "title"
      ],
      "properties": {
        "description": {
          "description": "*description** is a text description of proposal. Non unique.",
          "type": "string"
        },
        "param_changes": {
          "description": "*param_changes** is a vector of params to be changed. Non unique.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ParamChange"
          }
        },
        "title": {
          "description": "*title** is a text title of proposal. Non unique.",
          "type": "string"
        }
      }
    },
    "PinCodesProposal": {
      "description": "Deprecated. PinCodesProposal defines the struct for pin contract codes proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "code_ids",
        "description",
        "title"
      ],
      "properties": {
        "code_ids": {
          "description": "*code_ids** is an array of codes to be pined.",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      }
    },
    "Plan": {
      "description": "Plan defines the struct for planned upgrade.",
      "type": "object",
      "required": [
        "height",
        "info",
        "name"
      ],
      "properties": {
        "height": {
          "description": "*height** is a height at which the upgrade must be performed",
          "type": "integer",
          "format": "int64"
        },
        "info": {
          "description": "*info** is any application specific upgrade info to be included on-chain",
          "type": "string"
        },
        "name": {
          "description": "*name** is a name for the upgrade",
          "type": "string"
        }
      }
    },
    "ProposalExecuteMessage": {
      "description": "ProposalExecuteMessage defines the struct for sdk47 compatible admin proposal.",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "message": {
          "description": "*message** is a json representing an sdk message passed to admin module to execute.",
          "type": "string"
        }
      }
    },
    "ProtobufAny": {
      "description": "Type for wrapping any protobuf message",
      "type": "object",
      "required": [
        "type_url",
        "value"
      ],
      "properties": {
        "type_url": {
          "description": "*type_url** describes the type of the serialized message",
          "type": "string"
        },
        "value": {
          "description": "*value** must be a valid serialized protocol buffer of the above specified type",
          "allOf": [
            {
              "$ref": "#/definitions/Binary"
            }
          ]
        }
      }
    },
    "RequestPacketTimeoutHeight": {
      "type": "object",
      "properties": {
        "revision_height": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        },
        "revision_number": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "SoftwareUpgradeProposal": {
      "description": "Deprecated. SoftwareUpgradeProposal defines the struct for software upgrade proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "description",
        "plan",
        "title"
      ],
      "properties": {
        "description": {
          "description": "*description** is a text description of proposal. Non unique.",
          "type": "string"
        },
        "plan": {
          "description": "*plan** is a plan of upgrade.",
          "allOf": [
            {
              "$ref": "#/definitions/Plan"
            }
          ]
        },
        "title": {
          "description": "*title** is a text title of proposal. Non unique.",
          "type": "string"
        }
      }
    },
    "StakingMsg": {
      "description": "The message types of the staking module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto",
      "oneOf": [
        {
          "description": "This is translated to a [MsgDelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L81-L90). `delegator_address` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "delegate"
          ],
          "properties": {
            "delegate": {
              "type": "object",
              "required": [
                "amount",
                "validator"
              ],
              "properties": {
                "amount": {
                  "$ref": "#/definitions/Coin"
                },
                "validator": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "This is translated to a [MsgUndelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L112-L121). `delegator_address` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "undelegate"
          ],
          "properties": {
            "undelegate": {
              "type": "object",
              "required": [
                "amount",
                "validator"
              ],
              "properties": {
                "amount": {
                  "$ref": "#/definitions/Coin"
                },
                "validator": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "This is translated to a [MsgBeginRedelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L95-L105). `delegator_address` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "redelegate"
          ],
          "properties": {
            "redelegate": {
              "type": "object",
              "required": [
                "amount",
                "dst_validator",
                "src_validator"
              ],
              "properties": {
                "amount": {
                  "$ref": "#/definitions/Coin"
                },
                "dst_validator": {
                  "type": "string"
                },
                "src_validator": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "SudoContractProposal": {
      "description": "Deprecated. SudoContractProposal defines the struct for sudo execution proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "contract",
        "description",
        "msg",
        "title"
      ],
      "properties": {
        "contract": {
          "description": "*contract** is an address of contract to be executed.",
          "type": "string"
        },
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "msg": {
          "description": "**msg*** is a sudo message.",
          "allOf": [
            {
              "$ref": "#/definitions/Binary"
            }
          ]
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      }
    },
    "Timestamp": {
      "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
      "allOf": [
        {
          "$ref": "#/definitions/Uint64"
        }
      ]
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "Uint64": {
      "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
      "type": "string"
    },
    "UnpinCodesProposal": {
      "description": "Deprecated. UnpinCodesProposal defines the struct for unpin contract codes proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "code_ids",
        "description",
        "title"
      ],
      "properties": {
        "code_ids": {
          "description": "*code_ids** is an array of codes to be unpined.",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      }
    },
    "UpdateAdminProposal": {
      "description": "Deprecated. UpdateAdminProposal defines the struct for update admin proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "contract",
        "description",
        "new_admin",
        "title"
      ],
      "properties": {
        "contract": {
          "description": "*contract** is an address of contract to update admin.",
          "type": "string"
        },
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "new_admin": {
          "description": "**new_admin*** is an address of new admin",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      }
    },
    "UpgradeProposal": {
      "description": "UpgradeProposal defines the struct for IBC upgrade proposal.",
      "type": "object",
      "required": [
        "description",
        "plan",
        "title",
        "upgraded_client_state"
      ],
      "properties": {
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "plan": {
          "description": "*plan** is a plan of upgrade.",
          "allOf": [
            {
              "$ref": "#/definitions/Plan"
            }
          ]
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        },
        "upgraded_client_state": {
          "description": "*upgraded_client_state** is an upgraded client state.",
          "allOf": [
            {
              "$ref": "#/definitions/ProtobufAny"
            }
          ]
        }
      }
    },
    "VoteOption": {
      "type": "string",
      "enum": [
        "yes",
        "no",
        "abstain",
        "no_with_veto"
      ]
    },
    "WasmMsg": {
      "description": "The message types of the wasm module.\n\nSee https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto",
      "oneOf": [
        {
          "description": "Dispatches a call to another contract at a known address (with known ABI).\n\nThis is translated to a [MsgExecuteContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L68-L78). `sender` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "execute"
          ],
          "properties": {
            "execute": {
              "type": "object",
              "required": [
                "contract_addr",
                "funds",
                "msg"
              ],
              "properties": {
                "contract_addr": {
                  "type": "string"
                },
                "funds": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                },
                "msg": {
                  "description": "msg is the json-encoded ExecuteMsg struct (as raw Binary)",
                  "allOf": [
                    {
                      "$ref": "#/definitions/Binary"
                    }
                  ]
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Instantiates a new contracts from previously uploaded Wasm code.\n\nThe contract address is non-predictable. But it is guaranteed that when emitting the same Instantiate message multiple times, multiple instances on different addresses will be generated. See also Instantiate2.\n\nThis is translated to a [MsgInstantiateContract](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L53-L71). `sender` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "instantiate"
          ],
          "properties": {
            "instantiate": {
              "type": "object",
              "required": [
                "code_id",
                "funds",
                "label",
                "msg"
              ],
              "properties": {
                "admin": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "code_id": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                },
                "funds": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                },
                "label": {
                  "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                  "type": "string"
                },
                "msg": {
                  "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                  "allOf": [
                    {
                      "$ref": "#/definitions/Binary"
                    }
                  ]
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Migrates a given contracts to use new wasm code. Passes a MigrateMsg to allow us to customize behavior.\n\nOnly the contract admin (as defined in wasmd), if any, is able to make this call.\n\nThis is translated to a [MsgMigrateContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L86-L96). `sender` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "migrate"
          ],
          "properties": {
            "migrate": {
              "type": "object",
              "required": [
                "contract_addr",
                "msg",
                "new_code_id"
              ],
              "properties": {
                "contract_addr": {
                  "type": "string"
                },
                "msg": {
                  "description": "msg is the json-encoded MigrateMsg struct that will be passed to the new code",
                  "allOf": [
                    {
                      "$ref": "#/definitions/Binary"
                    }
                  ]
                },
                "new_code_id": {
                  "description": "the code_id of the new logic to place in the given contract",
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Sets a new admin (for migrate) on the given contract. Fails if this contract is not currently admin of the target contract.",
          "type": "object",
          "required": [
            "update_admin"
          ],
          "properties": {
            "update_admin": {
              "type": "object",
              "required": [
                "admin",
                "contract_addr"
              ],
              "properties": {
                "admin": {
                  "type": "string"
                },
                "contract_addr": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Clears the admin on the given contract, so no more migration possible. Fails if this contract is not currently admin of the target contract.",
          "type": "object",
          "required": [
            "clear_admin"
          ],
          "properties": {
            "clear_admin": {
              "type": "object",
              "required": [
                "contract_addr"
              ],
              "properties": {
                "contract_addr": {
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        }
      ]
    }
  }
}
