{
  "contract_name": "astroport-incentives",
  "contract_version": "1.3.1",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "astro_token",
      "factory",
      "owner",
      "vesting_contract"
    ],
    "properties": {
      "astro_token": {
        "$ref": "#/definitions/AssetInfo"
      },
      "factory": {
        "type": "string"
      },
      "guardian": {
        "type": [
          "string",
          "null"
        ]
      },
      "incentivization_fee_info": {
        "anyOf": [
          {
            "$ref": "#/definitions/IncentivizationFeeInfo"
          },
          {
            "type": "null"
          }
        ]
      },
      "owner": {
        "type": "string"
      },
      "vesting_contract": {
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "AssetInfo": {
        "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
        "oneOf": [
          {
            "description": "Non-native Token",
            "type": "object",
            "required": [
              "token"
            ],
            "properties": {
              "token": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "$ref": "#/definitions/Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Native token",
            "type": "object",
            "required": [
              "native_token"
            ],
            "properties": {
              "native_token": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "IncentivizationFeeInfo": {
        "type": "object",
        "required": [
          "fee",
          "fee_receiver"
        ],
        "properties": {
          "fee": {
            "description": "To make things easier we avoid CW20 fee tokens",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "fee_receiver": {
            "description": "Fee receiver can be either a contract or a wallet.",
            "allOf": [
              {
                "$ref": "#/definitions/Addr"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Setup generators with their respective allocation points. Only the owner or generator controller can execute this.",
        "type": "object",
        "required": [
          "setup_pools"
        ],
        "properties": {
          "setup_pools": {
            "type": "object",
            "required": [
              "pools"
            ],
            "properties": {
              "pools": {
                "description": "The list of pools with allocation point.",
                "type": "array",
                "items": {
                  "type": "array",
                  "items": [
                    {
                      "type": "string"
                    },
                    {
                      "$ref": "#/definitions/Uint128"
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update rewards and return it to user.",
        "type": "object",
        "required": [
          "claim_rewards"
        ],
        "properties": {
          "claim_rewards": {
            "type": "object",
            "required": [
              "lp_tokens"
            ],
            "properties": {
              "lp_tokens": {
                "description": "The LP token cw20 address or token factory denom",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Receives a message of type [`Cw20ReceiveMsg`]. Handles cw20 LP token deposits.",
        "type": "object",
        "required": [
          "receive"
        ],
        "properties": {
          "receive": {
            "$ref": "#/definitions/Cw20ReceiveMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Stake LP tokens in the Generator. LP tokens staked on behalf of recipient if recipient is set. Otherwise LP tokens are staked on behalf of message sender.",
        "type": "object",
        "required": [
          "deposit"
        ],
        "properties": {
          "deposit": {
            "type": "object",
            "properties": {
              "recipient": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Withdraw LP tokens from the Generator",
        "type": "object",
        "required": [
          "withdraw"
        ],
        "properties": {
          "withdraw": {
            "type": "object",
            "required": [
              "amount",
              "lp_token"
            ],
            "properties": {
              "amount": {
                "description": "The amount to withdraw. Must not exceed total staked amount.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              },
              "lp_token": {
                "description": "The LP token cw20 address or token factory denom",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Set a new amount of ASTRO to distribute per seconds. Only the owner can execute this.",
        "type": "object",
        "required": [
          "set_tokens_per_second"
        ],
        "properties": {
          "set_tokens_per_second": {
            "type": "object",
            "required": [
              "amount"
            ],
            "properties": {
              "amount": {
                "description": "The new amount of ASTRO to distribute per second",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Incentivize a pool with external rewards. Rewards can be in either native or cw20 form. Incentivizor must send incentivization fee along with rewards (if this reward token is new in this pool). 3rd parties are encouraged to keep endless schedules without breaks even with the small rewards. Otherwise, reward token will be removed from the pool info and go to outstanding rewards. Next schedules with the same token will be considered as \"new\". NOTE: Sender must approve allowance for cw20 reward tokens to this contract.",
        "type": "object",
        "required": [
          "incentivize"
        ],
        "properties": {
          "incentivize": {
            "type": "object",
            "required": [
              "lp_token",
              "schedule"
            ],
            "properties": {
              "lp_token": {
                "description": "The LP token cw20 address or token factory denom",
                "type": "string"
              },
              "schedule": {
                "description": "Incentives schedule",
                "allOf": [
                  {
                    "$ref": "#/definitions/InputSchedule"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Same as Incentivize endpoint but for multiple pools in one go.",
        "type": "object",
        "required": [
          "incentivize_many"
        ],
        "properties": {
          "incentivize_many": {
            "type": "array",
            "items": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/definitions/InputSchedule"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            }
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Remove specific reward token from the pool. Only the owner can execute this.",
        "type": "object",
        "required": [
          "remove_reward_from_pool"
        ],
        "properties": {
          "remove_reward_from_pool": {
            "type": "object",
            "required": [
              "lp_token",
              "receiver",
              "reward"
            ],
            "properties": {
              "bypass_upcoming_schedules": {
                "description": "If there is too much spam in the state, owner can bypass upcoming schedules; Tokens from these schedules will stuck in Generator balance forever. Set true only in emergency cases i.e. if deregistration message hits gas limit during simulation. Default: false",
                "default": false,
                "type": "boolean"
              },
              "lp_token": {
                "description": "The LP token cw20 address or token factory denom",
                "type": "string"
              },
              "receiver": {
                "description": "Receiver of unclaimed rewards",
                "type": "string"
              },
              "reward": {
                "description": "The reward token cw20 address or token factory denom",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Claim all or up to the limit accumulated orphaned rewards. Only the owner can execute this.",
        "type": "object",
        "required": [
          "claim_orphaned_rewards"
        ],
        "properties": {
          "claim_orphaned_rewards": {
            "type": "object",
            "required": [
              "receiver"
            ],
            "properties": {
              "limit": {
                "description": "Number of assets to claim",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint8",
                "minimum": 0.0
              },
              "receiver": {
                "description": "Receiver of orphaned rewards",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update config. Only the owner can execute it.",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "properties": {
              "astro_token": {
                "description": "The new ASTRO token info",
                "anyOf": [
                  {
                    "$ref": "#/definitions/AssetInfo"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "generator_controller": {
                "description": "The new generator controller contract address",
                "type": [
                  "string",
                  "null"
                ]
              },
              "guardian": {
                "description": "The new generator guardian",
                "type": [
                  "string",
                  "null"
                ]
              },
              "incentivization_fee_info": {
                "description": "New incentivization fee info",
                "anyOf": [
                  {
                    "$ref": "#/definitions/IncentivizationFeeInfo"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "token_transfer_gas_limit": {
                "description": "New external incentive token transfer gas limit",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "vesting_contract": {
                "description": "The new vesting contract address",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Add or remove token to the block list. Only owner or guardian can execute this. Pools which contain these tokens can't be incentivized with ASTRO rewards. Also blocked tokens can't be used as external reward. Current active pools with these tokens will be removed from active set.",
        "type": "object",
        "required": [
          "update_blocked_tokenslist"
        ],
        "properties": {
          "update_blocked_tokenslist": {
            "type": "object",
            "properties": {
              "add": {
                "description": "Tokens to add",
                "default": [],
                "type": "array",
                "items": {
                  "$ref": "#/definitions/AssetInfo"
                }
              },
              "remove": {
                "description": "Tokens to remove",
                "default": [],
                "type": "array",
                "items": {
                  "$ref": "#/definitions/AssetInfo"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only factory can set the allocation points to zero for the specified pool. Initiated from deregistration context in factory.",
        "type": "object",
        "required": [
          "deactivate_pool"
        ],
        "properties": {
          "deactivate_pool": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Go through active pools and deactivate the ones which pair type is blocked",
        "type": "object",
        "required": [
          "deactivate_blocked_pools"
        ],
        "properties": {
          "deactivate_blocked_pools": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Creates a request to change contract ownership Only the current owner can execute this.",
        "type": "object",
        "required": [
          "propose_new_owner"
        ],
        "properties": {
          "propose_new_owner": {
            "type": "object",
            "required": [
              "expires_in",
              "owner"
            ],
            "properties": {
              "expires_in": {
                "description": "The validity period of the proposal to change the contract owner",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "owner": {
                "description": "The newly proposed owner",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Removes a request to change contract ownership Only the current owner can execute this",
        "type": "object",
        "required": [
          "drop_ownership_proposal"
        ],
        "properties": {
          "drop_ownership_proposal": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Claims contract ownership Only the newly proposed owner can execute this",
        "type": "object",
        "required": [
          "claim_ownership"
        ],
        "properties": {
          "claim_ownership": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "Asset": {
        "description": "This enum describes a Terra asset (native or CW20).",
        "type": "object",
        "required": [
          "amount",
          "info"
        ],
        "properties": {
          "amount": {
            "description": "A token amount",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "info": {
            "description": "Information about an asset stored in a [`AssetInfo`] struct",
            "allOf": [
              {
                "$ref": "#/definitions/AssetInfo"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "AssetInfo": {
        "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
        "oneOf": [
          {
            "description": "Non-native Token",
            "type": "object",
            "required": [
              "token"
            ],
            "properties": {
              "token": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "$ref": "#/definitions/Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Native token",
            "type": "object",
            "required": [
              "native_token"
            ],
            "properties": {
              "native_token": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Cw20ReceiveMsg": {
        "description": "Cw20ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg",
        "type": "object",
        "required": [
          "amount",
          "msg",
          "sender"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "msg": {
            "$ref": "#/definitions/Binary"
          },
          "sender": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "IncentivizationFeeInfo": {
        "type": "object",
        "required": [
          "fee",
          "fee_receiver"
        ],
        "properties": {
          "fee": {
            "description": "To make things easier we avoid CW20 fee tokens",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "fee_receiver": {
            "description": "Fee receiver can be either a contract or a wallet.",
            "allOf": [
              {
                "$ref": "#/definitions/Addr"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "InputSchedule": {
        "type": "object",
        "required": [
          "duration_periods",
          "reward"
        ],
        "properties": {
          "duration_periods": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "reward": {
            "$ref": "#/definitions/Asset"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Config returns the main contract parameters",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Deposit returns the LP token amount deposited in a specific generator",
        "type": "object",
        "required": [
          "deposit"
        ],
        "properties": {
          "deposit": {
            "type": "object",
            "required": [
              "lp_token",
              "user"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              },
              "user": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "PendingToken returns the amount of rewards that can be claimed by an account that deposited a specific LP token in a generator",
        "type": "object",
        "required": [
          "pending_rewards"
        ],
        "properties": {
          "pending_rewards": {
            "type": "object",
            "required": [
              "lp_token",
              "user"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              },
              "user": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "RewardInfo returns reward information for a specified LP token",
        "type": "object",
        "required": [
          "reward_info"
        ],
        "properties": {
          "reward_info": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "PoolInfo returns information about a pool associated with the specified LP token",
        "type": "object",
        "required": [
          "pool_info"
        ],
        "properties": {
          "pool_info": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns a list of tuples with addresses and their staked amount",
        "type": "object",
        "required": [
          "pool_stakers"
        ],
        "properties": {
          "pool_stakers": {
            "type": "object",
            "required": [
              "lp_token"
            ],
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint8",
                "minimum": 0.0
              },
              "lp_token": {
                "type": "string"
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns paginated list of blocked tokens",
        "type": "object",
        "required": [
          "blocked_tokens_list"
        ],
        "properties": {
          "blocked_tokens_list": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint8",
                "minimum": 0.0
              },
              "start_after": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/AssetInfo"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Checks whether fee expected for the specified pool if user wants to add new reward schedule",
        "type": "object",
        "required": [
          "is_fee_expected"
        ],
        "properties": {
          "is_fee_expected": {
            "type": "object",
            "required": [
              "lp_token",
              "reward"
            ],
            "properties": {
              "lp_token": {
                "type": "string"
              },
              "reward": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the list of all external reward schedules for the specified LP token",
        "type": "object",
        "required": [
          "external_reward_schedules"
        ],
        "properties": {
          "external_reward_schedules": {
            "type": "object",
            "required": [
              "lp_token",
              "reward"
            ],
            "properties": {
              "limit": {
                "description": "Limit number of returned schedules.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint8",
                "minimum": 0.0
              },
              "lp_token": {
                "type": "string"
              },
              "reward": {
                "description": "Reward cw20 addr/denom",
                "type": "string"
              },
              "start_after": {
                "description": "Start after specified timestamp",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the list of all ever incentivized pools",
        "type": "object",
        "required": [
          "list_pools"
        ],
        "properties": {
          "list_pools": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Limit number of returned pools.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint8",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Start after specified LP token",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the list of all pools receiving astro emissions",
        "type": "object",
        "required": [
          "active_pools"
        ],
        "properties": {
          "active_pools": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "AssetInfo": {
        "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
        "oneOf": [
          {
            "description": "Non-native Token",
            "type": "object",
            "required": [
              "token"
            ],
            "properties": {
              "token": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "$ref": "#/definitions/Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Native token",
            "type": "object",
            "required": [
              "native_token"
            ],
            "properties": {
              "native_token": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "active_pools": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Tuple_of_String_and_Uint128",
      "type": "array",
      "items": {
        "type": "array",
        "items": [
          {
            "type": "string"
          },
          {
            "$ref": "#/definitions/Uint128"
          }
        ],
        "maxItems": 2,
        "minItems": 2
      },
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "blocked_tokens_list": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_AssetInfo",
      "type": "array",
      "items": {
        "$ref": "#/definitions/AssetInfo"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "type": "object",
      "required": [
        "astro_per_second",
        "astro_token",
        "factory",
        "owner",
        "total_alloc_points",
        "vesting_contract"
      ],
      "properties": {
        "astro_per_second": {
          "description": "Total amount of ASTRO rewards per second",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "astro_token": {
          "description": "[`AssetInfo`] of the ASTRO token",
          "allOf": [
            {
              "$ref": "#/definitions/AssetInfo"
            }
          ]
        },
        "factory": {
          "description": "The Factory address",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "generator_controller": {
          "description": "Contract address which can only set active generators and their alloc points",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "guardian": {
          "description": "The guardian address which can add or remove tokens from blacklist",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "incentivization_fee_info": {
          "description": "Defines native fee along with fee receiver. Fee is paid on adding NEW external reward to a specific pool",
          "anyOf": [
            {
              "$ref": "#/definitions/IncentivizationFeeInfo"
            },
            {
              "type": "null"
            }
          ]
        },
        "owner": {
          "description": "Address allowed to change contract parameters",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "token_transfer_gas_limit": {
          "description": "Max allowed gas limit per one external incentive token transfer. If token transfer hits this gas limit, reward will be considered as claimed while in reality it will be stuck in the contract. If None, there is no gas limit.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        },
        "total_alloc_points": {
          "description": "Total allocation points. Must be the sum of all allocation points in all active generators",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "vesting_contract": {
          "description": "The vesting contract which distributes internal (ASTRO) rewards",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "IncentivizationFeeInfo": {
          "type": "object",
          "required": [
            "fee",
            "fee_receiver"
          ],
          "properties": {
            "fee": {
              "description": "To make things easier we avoid CW20 fee tokens",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "fee_receiver": {
              "description": "Fee receiver can be either a contract or a wallet.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "deposit": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "external_reward_schedules": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_ScheduleResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/ScheduleResponse"
      },
      "definitions": {
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "ScheduleResponse": {
          "type": "object",
          "required": [
            "end_ts",
            "rps",
            "start_ts"
          ],
          "properties": {
            "end_ts": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "rps": {
              "$ref": "#/definitions/Decimal256"
            },
            "start_ts": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "is_fee_expected": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Boolean",
      "type": "boolean"
    },
    "list_pools": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "pending_rewards": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Asset",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Asset"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Asset": {
          "description": "This enum describes a Terra asset (native or CW20).",
          "type": "object",
          "required": [
            "amount",
            "info"
          ],
          "properties": {
            "amount": {
              "description": "A token amount",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "info": {
              "description": "Information about an asset stored in a [`AssetInfo`] struct",
              "allOf": [
                {
                  "$ref": "#/definitions/AssetInfo"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "AssetInfo": {
          "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "pool_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PoolInfoResponse",
      "type": "object",
      "required": [
        "last_update_ts",
        "rewards",
        "total_lp"
      ],
      "properties": {
        "last_update_ts": {
          "description": "Last time when reward indexes were updated",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "rewards": {
          "description": "Vector contains reward info for each reward token",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RewardInfo"
          }
        },
        "total_lp": {
          "description": "Total amount of LP tokens staked in this pool",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "RewardInfo": {
          "type": "object",
          "required": [
            "index",
            "orphaned",
            "reward",
            "rps"
          ],
          "properties": {
            "index": {
              "description": "Last checkpointed reward per LP token",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "orphaned": {
              "description": "Orphaned rewards might appear between the time when pool gets incentivized and the time when first user stakes",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "reward": {
              "description": "Defines [`AssetInfo`] of reward token as well as its type: protocol or external.",
              "allOf": [
                {
                  "$ref": "#/definitions/RewardType"
                }
              ]
            },
            "rps": {
              "description": "Reward tokens per second for the whole pool",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "RewardType": {
          "description": "This enum is a tiny wrapper over [`AssetInfo`] to differentiate between internal and external rewards. External rewards always have a next_update_ts field which is used to update reward per second (or disable them).",
          "oneOf": [
            {
              "description": "Internal rewards aka ASTRO emissions don't have next_update_ts field and they are paid out from Vesting contract.",
              "type": "object",
              "required": [
                "int"
              ],
              "properties": {
                "int": {
                  "$ref": "#/definitions/AssetInfo"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "External rewards always have corresponding schedules. Reward is paid out from Incentives contract balance.",
              "type": "object",
              "required": [
                "ext"
              ],
              "properties": {
                "ext": {
                  "type": "object",
                  "required": [
                    "info",
                    "next_update_ts"
                  ],
                  "properties": {
                    "info": {
                      "$ref": "#/definitions/AssetInfo"
                    },
                    "next_update_ts": {
                      "description": "Time when next schedule should start",
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "pool_stakers": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Tuple_of_String_and_Uint128",
      "type": "array",
      "items": {
        "type": "array",
        "items": [
          {
            "type": "string"
          },
          {
            "$ref": "#/definitions/Uint128"
          }
        ],
        "maxItems": 2,
        "minItems": 2
      },
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "reward_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_RewardInfo",
      "type": "array",
      "items": {
        "$ref": "#/definitions/RewardInfo"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "This enum describes available Token types. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"stake...\") }; NativeToken { denom: String::from(\"uluna\") }; ```",
          "oneOf": [
            {
              "description": "Non-native Token",
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "$ref": "#/definitions/Addr"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Native token",
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "RewardInfo": {
          "type": "object",
          "required": [
            "index",
            "orphaned",
            "reward",
            "rps"
          ],
          "properties": {
            "index": {
              "description": "Last checkpointed reward per LP token",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "orphaned": {
              "description": "Orphaned rewards might appear between the time when pool gets incentivized and the time when first user stakes",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            },
            "reward": {
              "description": "Defines [`AssetInfo`] of reward token as well as its type: protocol or external.",
              "allOf": [
                {
                  "$ref": "#/definitions/RewardType"
                }
              ]
            },
            "rps": {
              "description": "Reward tokens per second for the whole pool",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal256"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "RewardType": {
          "description": "This enum is a tiny wrapper over [`AssetInfo`] to differentiate between internal and external rewards. External rewards always have a next_update_ts field which is used to update reward per second (or disable them).",
          "oneOf": [
            {
              "description": "Internal rewards aka ASTRO emissions don't have next_update_ts field and they are paid out from Vesting contract.",
              "type": "object",
              "required": [
                "int"
              ],
              "properties": {
                "int": {
                  "$ref": "#/definitions/AssetInfo"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "External rewards always have corresponding schedules. Reward is paid out from Incentives contract balance.",
              "type": "object",
              "required": [
                "ext"
              ],
              "properties": {
                "ext": {
                  "type": "object",
                  "required": [
                    "info",
                    "next_update_ts"
                  ],
                  "properties": {
                    "info": {
                      "$ref": "#/definitions/AssetInfo"
                    },
                    "next_update_ts": {
                      "description": "Time when next schedule should start",
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    }
  }
}
